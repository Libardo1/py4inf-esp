% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{Variables, expresiones y afirmaciones}

\section{Valores y tipos}
\index{value}
\index{type}
\index{string}

Un {\bf valor} es una de las cosas b\'asicas con las que un programa trabaja tales como una letra o un n\'umero.  Los valores que hemos visto hasta ahora son {\tt 1}, {\tt 2}, y
\verb"'Hello, World!'".

Estos valores pertenecen a diferentes {\bf tipos}:
{\tt 2} es un n\'umero entero y \verb"'Hello, World!'" es una {\bf cadena de texto},
llamada as\'i por cuanto contiene una cadena (string) de letras.
Usted (y el int\'erprete) puede identificar cadenas de texto porque se encierran entre comillas (quotation mark).

\index{quotation mark}

El comando {\tt print} tambi\'en funciona para n\'umeros enteros.  Nosotros usamos el comando  
{\tt python} para ejecutar el int\'erprete.

\beforeverb
\begin{verbatim}
python
>>> print 4
4
\end{verbatim}
\afterverb
%
Si usted no tiene la seguridad de qu\'e valor tiene un tipo, el int\'erprete le puede decir.

\beforeverb
\begin{verbatim}
>>> type('Hello, World!')
<type 'str'>
>>> type(17)
<type 'int'>
\end{verbatim}
\afterverb
%
No cabe duda que las cadenas de texto (strings) pertenecen al tipo {\tt str} y los enteros pertenecen al tipo {\tt int}.  Menos obvio son los n\'umeros con puntos decimales que pertenecen al tipo llamado {\tt float}
porque estos n\'umeros se representan en un formato llamado {\bf floating-point}.

\index{type}
\index{string type}
\index{type!str}
\index{int type}
\index{type!int}
\index{float type}
\index{type!float}

\beforeverb
\begin{verbatim}
>>> type(3.2)
<type 'float'>
\end{verbatim}
\afterverb
%
En cuanto a valores como \verb"'17'" y \verb"'3.2'", aunque parecen n\'umeros, se encuentran entre comillas como cadenas de texto. 

\index{quotation mark}

\beforeverb
\begin{verbatim}
>>> type('17')
<type 'str'>
>>> type('3.2')
<type 'str'>
\end{verbatim}
\afterverb
%
Estas son cadenas (strings).

Cuando usted escribe un entero grande, puede tener la tentaci\'on de usar comas entre grupos de tres d\'igitos como en {\tt 1,000,000}. Esto no es correcto escribirlo como un entero legal en Python, pero s\'i es correcto:

\beforeverb
\begin{verbatim}
>>> print 1,000,000
1 0 0
\end{verbatim}
\afterverb
%
Bien, esto no es lo que esperamos. Python int\'erpreta {\tt
  1,000,000} como una secuencia de enteros separada por una coma, lo cual se imprime con spacios entre si.

\index{semantic error}
\index{error!semantic}
\index{error message}

Este es el primer ejemplo que tenemos de error de sem\'antica: el c\'odigo se ejecuta sin reportar error, pero no hace lo ``correcto''.


\section{Variables}
\index{variable}
\index{assignment statement}
\index{statement!assignment}

Una de las caracter\'isticas m\'as poderosas de un lenguage de programaci\'on es la capacidad de manipular  {\bf variables}. Una es un nombre que se refiere a un valor.

Una {\bf declaraci\'on} crea nuevas variables y asigna valores:

\beforeverb
\begin{verbatim}
>>> message = 'Y ahora para algo completamente diferente'
>>> n = 17
>>> pi = 3.1415926535897931
\end{verbatim}
\afterverb
%
Este ejemplo establece tres valores. La primera asigna una cadena a una nueva variable llamada {\tt message};
la segunda asigna un entero {\tt 17} a {\tt n}; la tercera asigna el valor (aproximado) de $\pi$ a {\tt pi}.

Para desplegar el valor de una variable, usted puede usar un comando para imprimir:

\beforeverb
\begin{verbatim}
>>> print n
17
>>> print pi
3.14159265359
\end{verbatim}
\afterverb
%
El tipo de variable es el tipo de valor al que se refiere.

\beforeverb
\begin{verbatim}
>>> type(message)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
\end{verbatim}
\afterverb
%

\section{Nombre de variable y palabras clave}
\index{keyword}

Los programadores generalmente escogen nombres para que sean significativos para sus variables ya que estos nombres documentan  para qu\'e son usadas las variables.

Los nombres de variable pueden ser arbitrariamente largas, pueden contener tanto letras como n\'umeros, pero deben comenzar con una letra. Es correcto utilizar may\'usculas, pero es mejor comenzar el nombre de una variable con letra min\'uscula(Usted podra apreciar porqu\'e m\'as adelante).

El signo de subrayar (\verb"_") puede aparecer en el nombre de la variable.
A menudo se utiliza en nombres de multiples palabras, como
\verb"mi_nombre" o \verb"aerodinamica-de-la-masa".
Los nombres de variable pueden empezar con un car\'acter de subrayado, pero generalmente se evita el uso a menos que se escriba c\'odigo bibliotecario para que otros lo usen.

\index{car\'acter de subrayado (underscore character)}

Si usted le da un nombre ilegal a una variable, le aparecer\'a un error sint\'actico:

\beforeverb
\begin{verbatim}
>>> 76trombones = 'big parade'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
{\tt 76trombones} es ilegal porque no comienza con una letra.
{\tt more@} es ilegal porque contiene un car\'actere ilegal, {\tt
@}.  Pero qu\'e tiene de malo {\tt class}?

Resulta que {\tt class} es una de las {\bf palabras clave (keywords)} de Python.  El int\'erprete utiliza palabras clave (keywords) para reconocer la estructura del programa,
y no se pueden utilizar para nombrar variables.

\index{keyword}

Python reserva 31 palabras clave o keywords\footnote{En Python 3.0, {\tt exec} ya no
se considera una palabra clave o keyword, pero {\tt nonlocal} s\'i.} para su uso:

\beforeverb
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}
\afterverb
%
Usted querr\'a mantener a la mano esta lista.  Si el int\'erprete le da un error sobre alguna de sus variables y no sabe porqu\'e, busque si la palabra que le da error aparece en esta lista.

\section{Afirmaciones o ``Statements"}

Una afirmaci\'on o {\bf statement} es una unidad de c\'odigo que le int\'erprete de Python puede ejecutar. Hemos visto dos tipos de "statements": print
y assignment.

\index{statement}
\index{interactive mode}
\index{script mode}

Cuando usted escribe una afirmaci\'on o "statement" en modo interactivo, el int\'erprete la ejecuta y despliega el resultado, si lo hay.

Un ``script" generalmente contiene una secuencia de afirmaciones o "statements". Si hay m\'as de una afirmaci\'on (o statement), el resultado aparace uno a uno en la medida en que son ejectutados.

Por ejemplo, el script:

\beforeverb
\begin{verbatim}
print 1
x = 2
print x
\end{verbatim}
\afterverb
%
produce el siguiente output

\beforeverb
\begin{verbatim}
1
2
\end{verbatim}
\afterverb
%
El statement asignado no produce output.


\section{Operadores y operandos}
\index{operator, arithmetic}
\index{arithmetic operator}
\index{operand}
\index{expression}

{\bf Operators} u operadores son s\'imbolos especiales que representan computaci\'on como suma y multiplicaci\'on. El valor al que el operador es aplicado se le llama operando u {\bf operands}.

Los operadores {\tt +}, {\tt -}, {\tt *}, {\tt /} and {\tt **}
realizan suma, subtracci\'on, multiplicac\'oion, divisi\'on y
exponentiac\'oion, como se muestra en los siguientes ejemplos:

\beforeverb
\begin{verbatim}
20+32   hour-1   hour*60+minute   minute/60   5**2   (5+9)*(15-7)
\end{verbatim}
\afterverb
%
Es posible que el operador de divisi\'on no haga lo que usted espera:

\beforeverb
\begin{verbatim}
>>> minute = 59
>>> minute/60
0
\end{verbatim}
\afterverb
%
El valor de {\tt minute} es 59, y en aritm\'etica convencional 59
dividido por 60 es 0.98333 y no 0.  La raz\'on de la discrepancia es que Python est\'a realizando {\bf floor division}\footnote{En Python 3.0,
el resultado de esta divisi\'on es un {\tt float}.  
En Python 3.0, el nuevo operador
{\tt //} realiza divisi\'o de enteros.}.

\index{Python 3.0}
\index{floor division}
\index{floating-point division}
\index{division!floor}
\index{division!floating-point}

Cuando ambos operandos son n\'umeros enteros, el resultado es tambi\'en un entero, ``floor division'' parte la fracci\'on, as\'i que en este ejemplo lo redondea a cero.

Si alguno de los operandos es un decimal o ``floating-point number'', Python realiza una 
divisi\'on de punto flotante (floating-point division), y el resultado es un flotante o {\tt float}:

\beforeverb
\begin{verbatim}
>>> minute/60.0
0.98333333333333328
\end{verbatim}
\afterverb


\section{Expresiones}


Una {\bf expresi\'on} es una combinaci\'on de valores, variables y operadores.
Un valor por s\'i mismo se considera una expresi\'on y as\'i mismo una variable, por esta raz\'on las siguientes son todas expresiones legales(asumiendo que a la variable {\tt x} se le ha asignada un valor):


\index{expression}
\index{evaluate}

\beforeverb
\begin{verbatim}
17
x
x + 17
\end{verbatim}
\afterverb
%

Si usted escribe una expresi\'on en modo interactivo, el int\'erprete lo
{\bf eval\'ua} y despliega el resultado:


\beforeverb
\begin{verbatim}
>>> 1 + 1
2
\end{verbatim}
\afterverb
%

Pero en un ``script'', una expresi\'on por s\'i misma no hace nada. Esto es una fuente de confusi\'on muy com\'un para principiantes.

\begin{ex}
Escriba la siguiente afirmaci\'on en el int\'erprete de Python para ver lo que hace:


\begin{ex}


\beforeverb
\begin{verbatim}
5
x = 5
x + 1
\end{verbatim}
\afterverb
%
\end{ex}



\section{Orden de operaciones}

\index{order of operations}
\index{rules of precedence}
\index{PEMDAS}


Cuando aparece m\'as de un operador en una expresi\'on, el orden de evaluaci\'on depende de las reglas de las {\bf reglas de precedencia}.  Para operadores matem\'aticos, Python sigue convenci\'on matem\'atica.
Las siglas {\bf PEMDAS} es una manera f\'acil de recordar las reglas:


\index{parentheses!overriding precedence}

\begin{itemize}


\item {\bf P}ar\'entesis tiene la m\'as alta precedencia y se puede usar para obligar una expres\'on a evaluar en el orden que usted quiere. Siendo que las expresiones entre par\'entesis se eval\'uan primero, , {\tt 2 * (3-1)} es 4,
y {\tt (1+1)**(5-2)} es 8. Usted tambi\'en puede usar par\'entesis para hacer una expresi\'on m\'as f\'acil de leer, como en  {\tt (minute * 100) / 60}, aunque el resultado no cambie.

\item {\bf E}xponenciaci\'on tiene la siguiente m\'as alta precedencia, as\'i que 
{\tt 2**1+1} es 3, no 4, y {\tt 3*1**3} es 3, no 27.

\item {\bf M}ultiplicaci\'on y {\bf D}ivisi\'on tiene la misma precedencia,
la cual es mayor que {\bf A}ddici\'on y {\bf S}ubtracci\'on, la que tambi\'en tiene igual precedencial. As\'i pues {\tt 2*3-1} es 5, no 4, y
{\tt 6+4/2} es 8, no 5.

\item Operadores con la misma precedencia son evaluados de izquierda a derecha. As\'i que la expresi\'on {\tt 5-3-1} es 1, no 3 porque el 
{\tt 5-3} ocurre primero y luego {\tt 1} se substrae de {\tt 2}.

\end{itemize}

Cuando tenga duda, siempre ponga par\'entesis en sus expresiones para asegurarse que la computaci\'on se realicen en el order que usted intenta.

\section{Operador de m\'odulos (Modulus operator)}




\index{modulus operator}
\index{operator!modulus}


El {\bf ``modulus operator''} trabaja en n\'umeros enteros y deja el residuo cuando el primer operando se divide por el segundo. En Python, el 
``modulus operator'' es un signo de porcentaje (\verb"%").  The syntax is the same
como para otros operadores:


\beforeverb
\begin{verbatim}
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
\end{verbatim}
\afterverb
%

De modo que 7 dividido por 3 es 2 dejando 1 de residuo.

El ``modulus operator'' es sorpresivamente muy \'util. Por ejemplo, usted puede verificar si un n\'umero es divisible por otro---si
{\tt x \% y} es cero, entonces {\tt x} es divisible por {\tt y}.

\index{divisibilidad}

Tambi\'en, usted puede extraer el d\'igito del extremo derecho del d\'igito o d\'igitos de un n\'umero. Por ejemplo, {\tt x \% 10} da el d\'igito del extremo derecho de {\tt x} (en base 10).  As\'i mismo {\tt x \% 100}
da los dos \'ultimos d\'igitos.



\section{Operaci\'on en cadena}
\index{string!operation}
\index{operator!string}

El operador {\tt +} funciona con una cadena o ``strings'', pero no es suma en el sentido matem\'atico. Al contrario, realiza 
{\bf concatenaci\'on}, lo que significa que une las cadenas lig\'andolas as\'i:

\index{concatenaci\'on}












\index{string!operation}
\index{operator!string}



\beforeverb
\begin{verbatim}
>>> first = 10
>>> second = 15
>>> print first+second
25
>>> first = '100'
>>> second = '150'
>>> print first + second
100150
\end{verbatim}
\afterverb
%

El output de este programa es {\tt 100150}.

\section{Pedir al usuario ``input''}

\index{keyboard input}

Algunas veces vamos a tomar el valor para una variable del usuario mismo, valor que el usuario escribe usando el teclado.
Python provee una funci\'on integrada llamada \verb"raw_input" que toma input del teclado\footnote{En Python 3.0, esta funci\'on se llama 
  {\tt input}.}.  Cuando se llama esta funci\'on, el programa para y espera
para que el usuario escriba algo. Cuando el usuario presiona {\sf
  Return} o {\sf Enter}, el programa se reactiva y \verb"raw_input"
devuelve lo que es usuario escribe como una cadena de palabras.

\index{Python 3.0}
\index{raw\_input function}
\index{function!raw\_input}

\beforeverb
\begin{verbatim}
>>> input = raw_input()
Some silly stuff
>>> print input
Some silly stuff
\end{verbatim}
\afterverb
%
Antes de tomar el input del usuario, es una buena idea desplegar un mensaje indicando qu\'e debe escribir el usuario. Usted puede pasar una cadena de palabras o ``string'' a \verb"raw_input" para que lo desplegue al usuario antes de recibir el:

\index{prompt}

\beforeverb
\begin{verbatim}
>>> name = raw_input('What is your name?\n')
What is your name?
Chuck
>>> print name
Chuck
\end{verbatim}
\afterverb
%
La secuencia \verb"\n" al final representa una {\bf nueva l\'inea},
la cual es un car\'acter especial que generera un nuevo corte de \'inea. Por esto lo que escribe el usuario aparece debajo.

\index{newline o nueva l\'inea}

Si usted espera que el usuario escriba un n\'umero entero, usted puede tratar de convertir el valor escrito en {\tt int} usando la funci\'on {\tt int()}:

\beforeverb
\begin{verbatim}
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
\end{verbatim}
\afterverb
%
Pero si el usuario escribe otra cosa diferente a un ``string'' o cadena de d\'igitos,
le va a salir un error:

\beforeverb
\begin{verbatim}
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int()
\end{verbatim}
\afterverb
%
Vamos a ver m\'as adelante c\'omo manejar este tipo de error.

\index{ValueError}
\index{exception!ValueError}


\section{Comentarios}
\index{comment o comentario}

En la medidad que los programas se vuelvan m\'as grandes y m\'as complicados, se hace m\'as dif\'icil leerlos. El lenguage formal es denso y a vececes es dif\'icil mirar un segmento de c\'odigo y entender qu\'e hace o por qu\'e.

Por esta raz\'on, una buena idea es agreagar notas a sus programas para explicar
en un lenguage natural lo que hace el program. A estas notas se les llama
{\bf comentarios} y comienzan con el s\'imbolo \verb"#":

\beforeverb
\begin{verbatim}
# compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
\end{verbatim}
\afterverb
%
En este caso, el comentario aparece en una l\'inea por si solo. Tambi\'en se pueden poner comentarios al final de la l\'inea:

\beforeverb
\begin{verbatim}
percentage = (minute * 100) / 60     # percentage of an hour
\end{verbatim}
\afterverb
%
Todo lo que se encierre dentro de {\tt \#} desde el comienzo hasta el final de la l\'inea se ignora---no tiene ning\'un efecto en el programa.

Los comentarios son mayormente \'utiles cuando documentan caracter\'isticas del c\'odigo que no son obvias a simple vista.  Es razonable asumir que el lector puede entender
\emph{qu\'e} hace el c\'odigo; es mucho m\'as \'util explicar \emph{por qu\'e}.

El siguiente comentario es redundante con el c\'odigo  y no ofrece ninguna utilidad:

\beforeverb
\begin{verbatim}
v = 5     # assign 5 to v
\end{verbatim}
\afterverb
%
Este comentario contiene informaci\'on \'util que no se encuentra en el c\'odigo:

\beforeverb
\begin{verbatim}
v = 5     # velocity in meters/second. 
\end{verbatim}
\afterverb
%
Tener buenos nombres de variables reduce la necesidad de comentarios, pero
los nombres largos dificultan la lectura de expresiones complejas, as\'i que hay que elegir entre uno y otro.

\section{Elecci\'on de nombres de variables mnemot\'ecnicos}

\index{mnemonic, mnemot\'ecnico}

Siempre y cuando usted siga las sencillas reglas para nombrar variable naming y evite las palabras reservadas, usted tiene muchas opciones al nombrar sus variables.
Al principio, esta opci\'on puede ser confusa al leer un  
programa y al escribir sus propios programas. Por ejemplo, los siguientes tres programas son id\'enticos en t\'erminos de alcance,
pero muy diferentes al leerlos y tratar de entenderlos.

\beforeverb
\begin{verbatim}
a = 35.0
b = 12.50
c = a * b
print c

hours = 35.0
rate = 12.50
pay = hours * rate
print pay

x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print x1q3p9afd
\end{verbatim}
\afterverb
%
El int\'erprete de Python ve estos tres programas \emph{exactamente iguales}, pero los humanos los ven y los entienden de una manera muy diferente.  
Los humanos van a entender m\'as r\'apidamente la {\bf intenci\'on} 
del segundo programa porque el  
programador ha escogido nombres de variable que reflejan la intenci\'on del programador
con relaci\'on a los datos que se almacenan en cada variable.

A estos nombres de variables sabiamente escogidas se les llama ``nombres de variable mnemot\'ecnicos''. La palabra \emph{mnemot\'ecnica}\footnote{V\'ease 
\url{http://en.wikipedia.org/wiki/Mnemonic}
para una descripci\'on extendida de la palabra ``mnemonic''.} 
que significa ``ayuda a memorizar''.
Se escogen nombres de variable mnemot\'ecnicas para ayudar a recordar, en primer lugar, porqu\'e se ha creado la variable.

Mientras que todo esto suena bien y es una buena idea utilizar variables mnemot\'ecnicas, este tipo de variables pueden obstaculizar el paso del programador aprendiz en su habilidad de analizar y comprender el c\'odigo. Esto se debe a que el principiante en programaci\'on no ha memorizado aun las palabras reservadas (\'estas son solo 31) y algunas veces nombres de variables que son demasiado descriptivas comienzan a verse como
parte del lenguage y no como simples nombres de variables bien escogidas.

Tome nota del siguiente ejemplo de c\'odigo de Python que circula (loop) entre los mismos datos.  Cubriremos el concepto de ``loops'' pronto, pero por ahora trate de pensar en lo que significa:

\beforeverb
\begin{verbatim}
for word in words:
    print word
\end{verbatim}
\afterverb
%
`?Qu\'e est\'a ocurriendo aqu\'i?  `?Cu\'al de los signos (for, word, in, etc.) son palabras reservadas
y cu\'ales son simplemente nombres de variables?  `?Entiende Python en un nivel fundamental la noci\'on de palabras?  Los programadores principiantes tienen dificultad separando las partes de c\'odigo que \emph{deben} ser igual en este ejemplo y las partes del c\'odigo que son simplemente selecciones hechas por el programador.

El siguiente c\'odigo es equivalent al c\'odigo de arriba:

\beforeverb
\begin{verbatim}
for slice in pizza:
    print slice
\end{verbatim}
\afterverb
%
Es m\'as f\'acil para el programador principiante ver todo el c\'odigo y saber qu\'e partes son palabras reservadas definidas por Python y qu\'e partes son simplemente nombres de variables escogidas por el programador. Es claro que Python no tiene una comprensi\'on fundamental de pizza y pedazos y el hecho de que una pizza consiste de una o m\'as pedazos.

Pero si nuestro programa es sobre lectura de datos y encontrar palabras en los datos,
{\tt pizza} y {\tt slice} (pedazos) son nombres de variables mnemot\'ecnicos. Escogerlos como variables distrae la atenci\'on del significado del programa.

Despu\'es de un corto tiempo, usted aprender\'a las palabras reservadas m\'as comunes y comenzar\'a a ver las palabras reservadas como si le saltaran a la vista:

{\tt {\bf for} word {\bf in} words{\bf :}\\
\verb"    "{\bf print} word }

Las partes del c\'odigo que est\'an definidas por Python ({\tt for}, {\tt in}, {\tt print}, y {\tt :}) est\'an en negrilla y las variables que escogi\'o el programador ({\tt word} y {\tt words}) no est\'an en negrilla.  
Muchos editores de texto conocen la sint\'actica de Python
y colorean las palabras reservadas de manera diferente para darle una clave y ayudarle a separar sus variables de las palabras reservadas.
Despu\'es de cierto tiempo usted empezar\'a a leer Python y r\'apidamente determinar qu\'e es una variable y qu\'e es una palabra reservada.

\section{Depuraci\'on}
\index{debugging o depuraci\'on}

Hasta aqu\'i el error sint\'actico m\'as com\'un que usted vaya a cometer es un nombre de variable ilegal, como {\tt class} y {\tt yield}, las cuales son palabras claves, o \verb"odd~job" y \verb"US$", los cuales contienen car\'acteres ilegales.

\index{syntax error o error sint\'actico}
\index{error!syntax}

Si usted coloca un espacio en el nomre de una variable, Python cree que son dos 
operandos sin un operador:

\beforeverb
\begin{verbatim}
>>> bad name = 5
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
Para los errores sint\'acticos, el mensaje de error no es muy \'util.
Los mensajes m\'as comunes son {\tt SyntaxError: invalid syntax} y
{\tt SyntaxError: invalid token}, ninguno de los dos es muy informativo.

\index{error message}
\index{use before def}
\index{exception}
\index{runtime error}
\index{error!runtime}

El error en tiempo de ejecuci\'on o ``runtime error'' m\'as com\'un que usted va a cometer es un ``use before
def;'' que significa tratar de usar una variable antes que le haya asignado
un valor. Esto ocurre si usted escribe mal el nombre de la variable:

\beforeverb
\begin{verbatim}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
\end{verbatim}
\afterverb
%
Los nombres de variables son sensibles al uso de may\'usculas y min\'usculas, as\'i que {\tt LaTeX} no es lo mismo que {\tt latex}.

\index{case-sensitivity, variable names}
\index{semantic error}
\index{error!semantic}

Hasta aqu\'i la causa m\'as com\'un de error sint\'actico es el orden de operaci\'n. Por ejemplo, para evaluar $\frac{1}{2 \pi}$,
usted puede tener la tentaci\'on de escribir

\beforeverb
\begin{verbatim}
>>> 1.0 / 2.0 * pi
\end{verbatim}
\afterverb
%
Per la divisi\'on ocurre primero, as\'i que el resultado que usted tendr\'ia ser\'ia $\pi / 2$, lo cual no es la misma cosa. No hay ninguna manera que Python
sepa lo que usted quiere escribir, de modo que, en este caso, a usted no le aparecer\'ia un mensaje de error; solo obtendr\'ia la respuesta incorrecta.


\index{orden de operaciones}


\section{Glosario}

\begin{description}

\item[assignment o asignatura:]  Una afirmaci\'on que asigna un valor a una variable.
\index{assignment o asignatura}

\index{order of operations}



\item[concatenar:]  Unir dos operandos.
\index{concatenar}


\item[comentario:]  Informaci\'on en un programa con el prop\'osito de informar a otros programadores (o cualquiera que lea el c\'odigo fuente) y que no tiene efecto alguno en la ejecuci\'on del programa.
\index{comentario}

\item[evaluar:]  Simplificar una expresi\'on al realizar las operaciones para obtener un solo valor.

\item[expression o expresi\'on:]  Una combinaci\'on de variables, operadores y valores que
representa un resultado de valor singular.
\index{expression o expresi\'on}

\item[floating-point o punto flotante:] Un tipo que representa n\'umeros con partes en fracciones.
\index{floating-point o punto flotante}

\item[floor division:] La operaci\'on que divide dos n\'umeros y parte la secci\'on de la fracci\'on.
\index{floor division}

\item[integer o n\'umero entero:] Un tipo que representa n\'umeros enteros.
\index{integer o n\'umero entero}

\item[keyword o palabra clave:]  Una palabra reservada que usa el compilador para analizar un programa. Usted no puede usar palabras claves como {\tt if}, {\tt  def}, y {\tt while} para nombrar
variables.
\index{keyword o palabra clave}

\item[mnemot\'ecnicas:] Una ayuda para recordar. A menudo damos a las variables nombres con menmot\'ecnicas para ayudarnos a recordar lo que se almacena en la variable.
\index{mnemot\'ecnica}

\item[modulus operator o m\'odulo operador:]  Un operador denotado con un signo de porcentaje
({\tt \%}), que funciona en n\'umeros enteros y deja un residuo cuando un n\'umero es dividido por otro.
\index{modulus operator o m\'odulo operador}
\index{operator!modulus}

\item[operando:]  Uno de los valores en el que un operador opera.
\index{operando}

\item[operador:]  Un s\'imbolo especial que representa un calculo simple como suma, multiplicaci\'on o concatenaci\'on de cadenas (string).
\index{operador}

\item[reglas de precedencia:]  La serie de reglas que gobieran el orden en el cual se eval\'uan las expresiones que involucran m\'ultiples operadores y operandos.
\index{rules of precedence o reglas de precedencia}
\index{precedence}

\item[statement o afirmaci\'on:]  Un segmento de c\'odigo que representa un comando o acci\'on. Hasta ahora, las afirmaciones que hemos visto son asignaturas y comandos de impresi\'on (print statements).
\index{statement}

\item[string o cadena:] Un tipo que representa una secuencia de car\'acteres.
\index{string}

\item[tipo:] Una categoria de valores.  Los tipos que hemos visto hasta ahora son n\'umeros enteros (tipo {\tt int}), punto flotante (n\'umero decimal) (type {\tt
float}), y cadena o ``strings'' (type {\tt str}).
\index{type}

\item[valor:]  Uno de las unidades b\'asicas de datos, como un n\'umero o una cadena de palabras que un programa manipula.
\index{value}

\item[variable:]  Un nombre que se refiere a un valor.









\end{description}

\section{Exercicios}

\begin{ex}

Escriba un programa que use \verb"raw_input" que requiera que el usuario entre su nombre y luego le de la bienvenida.



\begin{verbatim}
Enter your name: Chuck
Hello Chuck
\end{verbatim}

\end{ex}

\begin{ex}

Escriba un programa que requiera del usuario entrar las horas y el valor por hora para calcular el pago total.


\begin{verbatim}
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
\end{verbatim}
\end{ex}
%

No nos preocuparemos de que el salario tenga exactamente dos d\'igitos despu\'es del decimal, por ahora. Si usted quiere, puede ensayar con las functiones integradas de Python {\tt round} para redondear apropiadamente el resultado del pago en dos espacios decimales.

\begin{ex}
Asuma que ejecutamos la siguiente asignaci\'on de las afirmaciones:





\begin{verbatim}
width = 17
height = 12.0
\end{verbatim}


Para cada una de las siguientes expresiones, escriba el valor de la expresi\'on y el tipo del valor de la expresi\'on.



\begin{enumerate}

\item {\tt width/2}

\item {\tt width/2.0}

\item {\tt height/3}

\item {\tt 1 + 2 * 5}

\end{enumerate}


Use el int\'erprete de Python para verificar sus respuestas.
\end{ex}

\begin{ex}
Escriba un programa que requiera que el usuario entre la temperatura en celsius,
convierta la medida a Fahrenheit e imprima el resultado de la temperatura que ha sido convertida.



\end{ex}


