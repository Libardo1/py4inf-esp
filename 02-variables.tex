% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{Variables, expresiones y afirmaciones}

\section{Valores y tipos}
\index{value}
\index{type}
\index{string}

Un {\bf valor} es una de las cosas b\'asicas con las que un programa trabaja tales como una letra o un n\'umero.  Los valores que hemos visto hasta ahora son {\tt 1}, {\tt 2}, y
\verb"'Hello, World!'".

Estos valores pertenecen a diferentes {\bf tipos}:
{\tt 2} es un n\'umero entero y \verb"'Hello, World!'" es una {\bf cadena de texto},
llamada as\'i por cuanto contiene una cadena (string) de letras.
Usted (y el int\'erprete) puede identificar cadenas de texto porque se encierran entre comillas (quotation mark).

\index{quotation mark}

El comando {\tt print} tambi\'en funciona para n\'umeros enteros.  Nosotros usamos el comando  
{\tt python} para ejecutar el int\'erprete.

\beforeverb
\begin{verbatim}
python
>>> print 4
4
\end{verbatim}
\afterverb
%
Si usted no tiene la seguridad de qu\'e valor tiene un tipo, el int\'erprete le puede decir.

\beforeverb
\begin{verbatim}
>>> type('Hello, World!')
<type 'str'>
>>> type(17)
<type 'int'>
\end{verbatim}
\afterverb
%
No cabe duda que las cadenas de texto (strings) pertenecen al tipo {\tt str} y los enteros pertenecen al tipo {\tt int}.  Menos obvio son los n\'umeros con puntos decimales que pertenecen al tipo llamado {\tt float}
porque estos n\'umeros se representan en un formato llamado {\bf floating-point}.

\index{type}
\index{string type}
\index{type!str}
\index{int type}
\index{type!int}
\index{float type}
\index{type!float}

\beforeverb
\begin{verbatim}
>>> type(3.2)
<type 'float'>
\end{verbatim}
\afterverb
%
En cuanto a valores como \verb"'17'" y \verb"'3.2'", aunque parecen n\'umeros, se encuentran entre comillas como cadenas de texto. 

\index{quotation mark}

\beforeverb
\begin{verbatim}
>>> type('17')
<type 'str'>
>>> type('3.2')
<type 'str'>
\end{verbatim}
\afterverb
%
Estas son cadenas (strings).

Cuando usted escribe un entero grande, puede tener la tentaci\'on de usar comas entre grupos de tres d\'igitos como en {\tt 1,000,000}. Esto no es correcto escribirlo como un entero legal en Python, pero s\'i es correcto:

\beforeverb
\begin{verbatim}
>>> print 1,000,000
1 0 0
\end{verbatim}
\afterverb
%
Bien, esto no es lo que esperamos. Python int\'erpreta {\tt
  1,000,000} como una secuencia de enteros separada por una coma, lo cual se imprime con spacios entre si.

\index{semantic error}
\index{error!semantic}
\index{error message}

Este es el primer ejemplo que tenemos de error de sem\'antica: el c\'odigo se ejecuta sin reportar error, pero no hace lo ``correcto''.


\section{Variables}
\index{variable}
\index{assignment statement}
\index{statement!assignment}

Una de las caracter\'isticas m\'as poderosas de un lenguage de programaci\'on es la capacidad de manipular  {\bf variables}. Una es un nombre que se refiere a un valor.

Una {\bf declaraci\'on} crea nuevas variables y asigna valores:

\beforeverb
\begin{verbatim}
>>> message = 'Y ahora para algo completamente diferente'
>>> n = 17
>>> pi = 3.1415926535897931
\end{verbatim}
\afterverb
%
Este ejemplo establece tres valores. La primera asigna una cadena a una nueva variable llamada {\tt message};
la segunda asigna un entero {\tt 17} a {\tt n}; la tercera asigna el valor (aproximado) de $\pi$ a {\tt pi}.

Para desplegar el valor de una variable, usted puede usar un comando para imprimir:

\beforeverb
\begin{verbatim}
>>> print n
17
>>> print pi
3.14159265359
\end{verbatim}
\afterverb
%
El tipo de variable es el tipo de valor al que se refiere.

\beforeverb
\begin{verbatim}
>>> type(message)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
\end{verbatim}
\afterverb
%

\section{Nombre de variable y palabras clave}
\index{keyword}

Los programadores generalmente escogen nombres para que sean significativos para sus variables ya que estos nombres documentan  para qu\'e son usadas las variables.

Los nombres de variable pueden ser arbitrariamente largas, pueden contener tanto letras como n\'umeros, pero deben comenzar con una letra. Es correcto utilizar may\'usculas, pero es mejor comenzar el nombre de una variable con letra min\'uscula(Usted podra apreciar porqu\'e m\'as adelante).

El signo de subrayar (\verb"_") puede aparecer en el nombre de la variable.
A menudo se utiliza en nombres de multiples palabras, como
\verb"mi_nombre" o \verb"aerodinamica-de-la-masa".
Los nombres de variable pueden empezar con un car\'acter de subrayado, pero generalmente se evita el uso a menos que se escriba c\'odigo bibliotecario para que otros lo usen.

\index{car\'acter de subrayado (underscore character)}

Si usted le da un nombre ilegal a una variable, le aparecer\'a un error sint\'actico:

\beforeverb
\begin{verbatim}
>>> 76trombones = 'big parade'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
{\tt 76trombones} es ilegal porque no comienza con una letra.
{\tt more@} es ilegal porque contiene un car\'actere ilegal, {\tt
@}.  Pero qu\'e tiene de malo {\tt class}?

Resulta que {\tt class} es una de las {\bf palabras clave (keywords)} de Python.  El int\'erprete utiliza palabras clave (keywords) para reconocer la estructura del programa,
y no se pueden utilizar para nombrar variables.

\index{keyword}

Python reserva 31 palabras clave o keywords\footnote{En Python 3.0, {\tt exec} ya no
se considera una palabra clave o keyword, pero {\tt nonlocal} s\'i.} para su uso:

\beforeverb
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}
\afterverb
%
Usted querr\'a mantener a la mano esta lista.  Si el int\'erprete le da un error sobre alguna de sus variables y no sabe porqu\'e, busque si la palabra que le da error aparece en esta lista.

\section{Afirmaciones o ``Statements"}

Una afirmaci\'on o {\bf statement} es una unidad de c\'odigo que le int\'erprete de Python puede ejecutar. Hemos visto dos tipos de "statements": print
y assignment.

\index{statement}
\index{interactive mode}
\index{script mode}

Cuando usted escribe una afirmaci\'on o "statement" en modo interactivo, el int\'erprete la ejecuta y despliega el resultado, si lo hay.

Un ``script" generalmente contiene una secuencia de afirmaciones o "statements". Si hay m\'as de una afirmaci\'on (o statement), el resultado aparace uno a uno en la medida en que son ejectutados.

Por ejemplo, el script:

\beforeverb
\begin{verbatim}
print 1
x = 2
print x
\end{verbatim}
\afterverb
%
produce el siguiente output

\beforeverb
\begin{verbatim}
1
2
\end{verbatim}
\afterverb
%
El statement asignado no produce output.


\section{Operadores y operandos}
\index{operator, arithmetic}
\index{arithmetic operator}
\index{operand}
\index{expression}

{\bf Operators} u operadores son s\'imbolos especiales que representan computaci\'on como suma y multiplicaci\'on. El valor al que el operador es aplicado se le llama operando u {\bf operands}.

Los operadores {\tt +}, {\tt -}, {\tt *}, {\tt /} and {\tt **}
realizan suma, subtracci\'on, multiplicac\'oion, divisi\'on y
exponentiac\'oion, como se muestra en los siguientes ejemplos:

\beforeverb
\begin{verbatim}
20+32   hour-1   hour*60+minute   minute/60   5**2   (5+9)*(15-7)
\end{verbatim}
\afterverb
%
Es posible que el operador de divisi\'on no haga lo que usted espera:

\beforeverb
\begin{verbatim}
>>> minute = 59
>>> minute/60
0
\end{verbatim}
\afterverb
%
El valor de {\tt minute} es 59, y en aritm\'etica convencional 59
dividido por 60 es 0.98333 y no 0.  La raz\'on de la discrepancia es que Python est\'a realizando {\bf floor division}\footnote{En Python 3.0,
el resultado de esta divisi\'on es un {\tt float}.  
En Python 3.0, el nuevo operador
{\tt //} realiza divisi\'o de enteros.}.

\index{Python 3.0}
\index{floor division}
\index{floating-point division}
\index{division!floor}
\index{division!floating-point}

Cuando ambos operandos son n\'umeros enteros, el resultado es tambi\'en un entero, ``floor division'' parte la fracci\'on, as\'i que en este ejemplo lo redondea a cero.

Si alguno de los operandos es un decimal o ``floating-point number'', Python realiza una 
divisi\'on de punto flotante (floating-point division), y el resultado es un flotante o {\tt float}:

\beforeverb
\begin{verbatim}
>>> minute/60.0
0.98333333333333328
\end{verbatim}
\afterverb


\section{Expresiones}

<<<<<<< HEAD
Una {\bf expresi\'on} es una combinaci\'on de valores, variables y operadores.
Un valor por s\'i mismo se considera una expresi\'on y as\'i mismo una variable, por esta raz\'on las siguientes son todas expresiones legales(asumiendo que a la variable {\tt x} se le ha asignada un valor):
=======
An {\bf expression} is a combination of values, variables, and operators.
A value all by itself is considered an expression, and so is
a variable, so the following are all legal expressions
(assuming that the variable {\tt x} has been assigned a value):
>>>>>>> origin/master

\index{expression}
\index{evaluate}

\beforeverb
\begin{verbatim}
17
x
x + 17
\end{verbatim}
\afterverb
%
<<<<<<< HEAD
Si usted escribe una expresi\'on en modo interactivo, el int\'erprete lo
{\bf eval\'ua} y despliega el resultado:
=======
If you type an expression in interactive mode, the interpreter
{\bf evaluates} it and displays the result:
>>>>>>> origin/master

\beforeverb
\begin{verbatim}
>>> 1 + 1
2
\end{verbatim}
\afterverb
%
<<<<<<< HEAD
Pero en un ``script'', una expresi\'on por s\'i misma no hace nada. Esto es una fuente de confusi\'on muy com\'un para principiantes.

\begin{ex}
Escriba la siguiente afirmaci\'on en el int\'erprete de Python para ver lo que hace:
=======
But in a script, an expression all by itself doesn't
do anything!  This is a common
source of confusion for beginners.

\begin{ex}
Type the following statements in the Python interpreter to see
what they do:
>>>>>>> origin/master

\beforeverb
\begin{verbatim}
5
x = 5
x + 1
\end{verbatim}
\afterverb
%
\end{ex}


<<<<<<< HEAD
\section{Orden de operaciones}
=======
\section{Order of operations}
>>>>>>> origin/master
\index{order of operations}
\index{rules of precedence}
\index{PEMDAS}

<<<<<<< HEAD
Cuando aparece m\'as de un operador en una expresi\'on, el orden de evaluaci\'on depende de las reglas de las {\bf reglas de precedencia}.  Para operadores matem\'aticos, Python sigue convenci\'on matem\'atica.
Las siglas {\bf PEMDAS} es una manera f\'acil de recordar las reglas:
=======
When more than one operator appears in an expression, the order of
evaluation depends on the {\bf rules of precedence}.  For
mathematical operators, Python follows mathematical convention.
The acronym {\bf PEMDAS} is a useful way to
remember the rules:
>>>>>>> origin/master

\index{parentheses!overriding precedence}

\begin{itemize}

<<<<<<< HEAD
\item {\bf P}ar\'entesis tiene la m\'as alta precedencia y se puede usar para obligar una expres\'on a evaluar en el orden que usted quiere. Siendo que las expresiones entre par\'entesis se eval\'uan primero, , {\tt 2 * (3-1)} es 4,
y {\tt (1+1)**(5-2)} es 8. Usted tambi\'en puede usar par\'entesis para hacer una expresi\'on m\'as f\'acil de leer, como en  {\tt (minute * 100) / 60}, aunque el resultado no cambie.

\item {\bf E}xponenciaci\'on tiene la siguiente m\'as alta precedencia, as\'i que 
{\tt 2**1+1} es 3, no 4, y {\tt 3*1**3} es 3, no 27.

\item {\bf M}ultiplicaci\'on y {\bf D}ivisi\'n tiene la misma precedencia,
la cual es mayor que {\bf A}ddici\'n y {\bf S}ubtracci\'n, la que tambi\'en tiene igual precedencial. As\'i pues {\tt 2*3-1} es 5, no 4, y
{\tt 6+4/2} es 8, no 5.

\item Operadores con la misma precedencia son evaluados de izquierda a derecha. As\'i que la expresi\'on {\tt 5-3-1} es 1, no 3 porque el 
{\tt 5-3} ocurre primero y luego {\tt 1} se substrae de {\tt 2}.

\end{itemize}

Cuando tenga duda, siempre ponga par\'entesis en sus expresiones para asegurarse que la computaci\'on se realicen en el order que usted intenta.

\section{Operador de m\'odulos (Modulus operator)}
=======
\item {\bf P}arentheses have the highest precedence and can be used 
to force an expression to evaluate in the order you want. Since
expressions in parentheses are evaluated first, {\tt 2 * (3-1)} is 4,
and {\tt (1+1)**(5-2)} is 8. You can also use parentheses to make an
expression easier to read, as in {\tt (minute * 100) / 60}, even
if it doesn't change the result.

\item {\bf E}xponentiation has the next highest precedence, so
{\tt 2**1+1} is 3, not 4, and {\tt 3*1**3} is 3, not 27.

\item {\bf M}ultiplication and {\bf D}ivision have the same precedence,
which is higher than {\bf A}ddition and {\bf S}ubtraction, which also
have the same precedence.  So {\tt 2*3-1} is 5, not 4, and
{\tt 6+4/2} is 8, not 5.

\item Operators with the same precedence are evaluated from left to 
right.  So in the expression {\tt 5-3-1} is 1, not 3 because the
{\tt 5-3} happens first and then {\tt 1} is subtracted from {\tt 2}.

\end{itemize}

When in doubt always put parentheses in your expressions to make sure
the computations are performed in the order you intend.

\section{Modulus operator}
>>>>>>> origin/master

\index{modulus operator}
\index{operator!modulus}

<<<<<<< HEAD
El {\bf ``modulus operator''} trabaja en n\'umeros enteros y deja el residuo cuando el primer operando se divide por el segundo. En Python, el 
``modulus operator'' es un signo de porcentaje (\verb"%").  The syntax is the same
como para otros operadores:
=======
The {\bf modulus operator} works on integers and yields the remainder
when the first operand is divided by the second.  In Python, the
modulus operator is a percent sign (\verb"%").  The syntax is the same
as for other operators:
>>>>>>> origin/master

\beforeverb
\begin{verbatim}
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
\end{verbatim}
\afterverb
%
<<<<<<< HEAD
De modo que 7 dividido por 3 es 2 con 1 de residuo.

El ``modulus operator'' es sorpresivamente muy \'util. Por ejemplo, usted puede verificar si un n\'umero es divisible por otro---si
{\tt x \% y} es cero, entonces {\tt x} es divisible por {\tt y}.

\index{divisibilidad}

Tambi\'en, usted puede extraer el d\'igito del extremo derecho del d\'igito o d\'igitos de un n\'umero. Por ejemplo, {\tt x \% 10} da el d\'igito del extremo derecho de {\tt x} (en base 10).  As\'i mismo {\tt x \% 100}
da los dos \'ultimos d\'igitos.



\section{Operaci\'on en cadena}
\index{string!operation}
\index{operator!string}

El operador {\tt +} funciona con una cadena o ``strings'', pero no es suma en el sentido matem\'atico. Al contrario, realiza 
{\bf concatenaci\'on}, lo que significa que une las cadenas lig\'andolas as\'i:

\index{concatenaci\'on}
=======
So 7 divided by 3 is 2 with 1 left over.

The modulus operator turns out to be surprisingly useful.  For
example, you can check whether one number is divisible by another---if
{\tt x \% y} is zero, then {\tt x} is divisible by {\tt y}.

\index{divisibility}

Also, you can extract the right-most digit
or digits from a number.  For example, {\tt x \% 10} yields the
right-most digit of {\tt x} (in base 10).  Similarly {\tt x \% 100}
yields the last two digits.



\section{String operations}
\index{string!operation}
\index{operator!string}

The {\tt +} operator works with strings, but it
is not addition in the mathematical sense. Instead it performs
{\bf concatenation}, which means joining the strings by
linking them end-to-end.  For example:

\index{concatenation}
>>>>>>> origin/master

\beforeverb
\begin{verbatim}
>>> first = 10
>>> second = 15
>>> print first+second
25
>>> first = '100'
>>> second = '150'
>>> print first + second
100150
\end{verbatim}
\afterverb
%
<<<<<<< HEAD
El output de este programa es {\tt 100150}.

\section{Pedir al usuario ``input''}
=======
The output of this program is {\tt 100150}.

\section{Asking the user for input}
>>>>>>> origin/master
\index{keyboard input}

Sometimes we would like to take the value for a variable from the user
via their keyboard.
Python provides a built-in function called \verb"raw_input" that gets
input from the keyboard\footnote{In Python 3.0, this function is named
  {\tt input}.}.  When this function is called, the program stops and
waits for the user to type something.  When the user presses {\sf
  Return} or {\sf Enter}, the program resumes and \verb"raw_input"
returns what the user typed as a string.

\index{Python 3.0}
\index{raw\_input function}
\index{function!raw\_input}

\beforeverb
\begin{verbatim}
>>> input = raw_input()
Some silly stuff
>>> print input
Some silly stuff
\end{verbatim}
\afterverb
%
Before getting input from the user, it is a good idea to print a
prompt telling the user what to input.  You can pass a string
to \verb"raw_input" to be displayed to the user before pausing
for input:

\index{prompt}

\beforeverb
\begin{verbatim}
>>> name = raw_input('What is your name?\n')
What is your name?
Chuck
>>> print name
Chuck
\end{verbatim}
\afterverb
%
The sequence \verb"\n" at the end of the prompt represents a {\bf newline},
which is a special character that causes a line break.
That's why the user's input appears below the prompt.

\index{newline}

If you expect the user to type an integer, you can try to convert
the return value to {\tt int} using the {\tt int()} function:

\beforeverb
\begin{verbatim}
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
\end{verbatim}
\afterverb
%
But if the user types something other than a string of digits,
you get an error:

\beforeverb
\begin{verbatim}
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int()
\end{verbatim}
\afterverb
%
We will see how to handle this kind of error later.

\index{ValueError}
\index{exception!ValueError}


\section{Comments}
\index{comment}

As programs get bigger and more complicated, they get more difficult
to read.  Formal languages are dense, and it is often difficult to
look at a piece of code and figure out what it is doing, or why.

For this reason, it is a good idea to add notes to your programs to explain
in natural language what the program is doing.  These notes are called
{\bf comments}, and they start with the \verb"#" symbol:

\beforeverb
\begin{verbatim}
# compute the percentage of the hour that has elapsed
percentage = (minute * 100) / 60
\end{verbatim}
\afterverb
%
In this case, the comment appears on a line by itself.  You can also put
comments at the end of a line:

\beforeverb
\begin{verbatim}
percentage = (minute * 100) / 60     # percentage of an hour
\end{verbatim}
\afterverb
%
Everything from the {\tt \#} to the end of the line is ignored---it
has no effect on the program.

Comments are most useful when they document non-obvious features of
the code.  It is reasonable to assume that the reader can figure out
\emph{what} the code does; it is much more useful to explain \emph{why}.

This comment is redundant with the code and useless:

\beforeverb
\begin{verbatim}
v = 5     # assign 5 to v
\end{verbatim}
\afterverb
%
This comment contains useful information that is not in the code:

\beforeverb
\begin{verbatim}
v = 5     # velocity in meters/second. 
\end{verbatim}
\afterverb
%
Good variable names can reduce the need for comments, but
long names can make complex expressions hard to read, so there is
a tradeoff.

\section{Choosing mnemonic variable names}

\index{mnemonic}

As long as you follow the simple rules of variable naming, and avoid
reserved words, you have a lot of choice when you name your variables.
In the beginning, this choice can be confusing both when you read a 
program and when you write your own programs.  For example, the
following three programs are identical in terms of what they accomplish,
but very different when you read them and try to understand them.

\beforeverb
\begin{verbatim}
a = 35.0
b = 12.50
c = a * b
print c

hours = 35.0
rate = 12.50
pay = hours * rate
print pay

x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print x1q3p9afd
\end{verbatim}
\afterverb
%
The Python interpreter sees all three of these programs as \emph{exactly the 
same} but humans see and understand these programs quite differently.  
Humans will most quickly understand the {\bf intent} 
of the second program because the 
programmer has chosen variable names that reflect the intent of the programmer
regarding what data will be stored in each variable.

We call these wisely-chosen variable names ``mnemonic variable names''.  The
word \emph{mnemonic}\footnote{See 
\url{http://en.wikipedia.org/wiki/Mnemonic}
for an extended description of the word ``mnemonic''.} 
means ``memory aid''.
We choose mnemonic variable names to help us remember why we created the variable
in the first place.

While this all sounds great, and it is a very good idea to use mnemonic variable
names, mnemonic variable names can get in the way of a beginning programmer's 
ability to parse and understand code.  This is because beginning programmers 
have not yet memorized the reserved words (there are only 31 of them) and sometimes
variables which have names that are too descriptive start to look like 
part of the language and not just well-chosen variable names.

Take a quick look at the following Python sample code which loops through some data. 
We will cover loops soon, but for now try to just puzzle through what this means:

\beforeverb
\begin{verbatim}
for word in words:
    print word
\end{verbatim}
\afterverb
%
What is happening here?  Which of the tokens (for, word, in, etc.) are reserved words
and which are just variable names?  Does Python understand at a fundamental level 
the notion of words?  Beginning programmers have 
trouble separating what parts of the
code \emph{must} be the same as this example and what parts of the code are simply
choices made by the programmer.

The following code is equivalent to the above code:

\beforeverb
\begin{verbatim}
for slice in pizza:
    print slice
\end{verbatim}
\afterverb
%
It is easier for the beginning programmer to look at this code and know which 
parts are reserved words defined by Python and which parts are simply variable
names chosen by the programmer.  It is pretty clear that Python has no fundamental
understanding of pizza and slices and the fact that a pizza consists of a set
of one or more slices.

But if our program is truly about reading data and looking for words in the data,
{\tt pizza} and {\tt slice} are very un-mnemonic variable names.  Choosing them 
as variable names distracts from the meaning of the program.

After a pretty short period of time, you will know the most common reserved words
and you will start to see the reserved words jumping out at you:

{\tt {\bf for} word {\bf in} words{\bf :}\\
\verb"    "{\bf print} word }

The parts of the code that are defined by 
Python ({\tt for}, {\tt in}, {\tt print}, and {\tt :}) are in bold
and the programmer chosen variables ({\tt word} and {\tt words}) are not in bold.  
Many text editors are aware of Python
syntax and will color reserved words differently to give you clues to keep 
your variables and reserved words separate.
After a while you will begin to read Python and quickly determine what
is a variable and what is a reserved word.

\section{Debugging}
\index{debugging}

At this point the syntax error you are most likely to make is
an illegal variable name, like {\tt class} and {\tt yield}, which
are keywords, or \verb"odd~job" and \verb"US$", which contain
illegal characters.

\index{syntax error}
\index{error!syntax}

If you put a space in a variable name, Python thinks it is two
operands without an operator:

\beforeverb
\begin{verbatim}
>>> bad name = 5
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
For syntax errors, the error messages don't help much.
The most common messages are {\tt SyntaxError: invalid syntax} and
{\tt SyntaxError: invalid token}, neither of which is very informative.

\index{error message}
\index{use before def}
\index{exception}
\index{runtime error}
\index{error!runtime}

The runtime error you are most likely to make is a ``use before
def;'' that is, trying to use a variable before you have assigned
a value.  This can happen if you spell a variable name wrong:

\beforeverb
\begin{verbatim}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
\end{verbatim}
\afterverb
%
Variables names are case sensitive, so {\tt LaTeX} is not the
same as {\tt latex}.

\index{case-sensitivity, variable names}
\index{semantic error}
\index{error!semantic}

At this point the most likely cause of a semantic error is
the order of operations.  For example, to evaluate $\frac{1}{2 \pi}$,
you might be tempted to write

\beforeverb
\begin{verbatim}
>>> 1.0 / 2.0 * pi
\end{verbatim}
\afterverb
%
But the division happens first, so you would get $\pi / 2$, which
is not the same thing!  There is no way for Python
to know what you meant to write, so in this case you don't
get an error message; you just get the wrong answer.

<<<<<<< HEAD
\index{orden de operaciones}


\section{Glosario}

\begin{description}

\item[assignment o asignatura:]  Una afirmaci\'on que asigna un valor a una variable.
\index{assignment o asignatura}
=======
\index{order of operations}


\section{Glossary}

\begin{description}

\item[assignment:]  A statement that assigns a value to a variable.
\index{assignment}
>>>>>>> origin/master

\item[concatenate:]  To join two operands end-to-end.
\index{concatenation}

<<<<<<< HEAD
\item[comentario:]  Informaci\'on en un programa con el prop\'osito de informar a otros programadores (o cualquiera que lea el c\'odigo fuente) y que no tiene efecto alguno en la ejecuci\'on del programa.
\index{comentario}

\item[evaluar:]  Simplificar una expresi\'on al realizar las operaciones para obtener un solo valor.

\item[expression o expresi\'on:]  Una combinaci\'on de variables, operadores y valores que
representa un resultado de valor singular.
\index{expression o expresi\'on}

\item[floating-point o punto flotante:] Un tipo que representa n\'umeros con partes en fracciones.
\index{floating-point o punto flotante}

\item[floor division:] La operaci\'on que divide dos n\'umeros y parte la secci\'on de la fracci\'on.
\index{floor division}

\item[integer o n\'umero entero:] Un tipo que representa n\'umeros enteros.
\index{integer o n\'umero entero}

\item[keyword o palabra clave:]  Una palabra reservada que usa el compilador para analizar un programa. Usted no puede usar palabras claves como {\tt if}, {\tt  def}, y {\tt while} para nombrar
variables.
\index{keyword o palabra clave}

\item[mnemot\'ecnicas:] Una ayuda para recordar. A menudo damos a las variables nombres con menmot\'ecnicas para ayudarnos a recordar lo que se almacena en la variable.
\index{mnemot\'ecnica}

\item[modulus operator o m\'odulo operador:]  Un operador denotado con un signo de porcentaje
({\tt \%}), que funciona en n\'umeros enteros y deja un residuo cuando un n\'umero es dividido por otro.
\index{modulus operator o m\'odulo operador}
\index{operator!modulus}

\item[operando:]  Uno de los valores en el que un operador opera.
\index{operando}

\item[operador:]  Un s\'imbolo especial que representa un calculo simple como suma, multiplicaci\'on o concatenaci\'on de cadenas (string).
\index{operador}

\item[reglas de precedencia:]  La serie de reglas que gobieran el orden en el cual se eval\'uan las expresiones que involucran m\'ultiples operadores y operandos.
\index{rules of precedence o reglas de precedencia}
\index{precedence}

\item[statement o afirmaci\'on:]  Un segmento de c\'odigo que representa un comando o acci\'on. Hasta ahora, las afirmaciones que hemos visto son asignaturas y comandos de impresi\'on (print statements).
\index{statement}

\item[string o cadena:] Un tipo que representa una secuencia de car\'acteres.
\index{string}

\item[tipo:] Una categoria de valores.  Los tipos que hemos visto hasta ahora son n\'umeros enteros (tipo {\tt int}), punto flotante (n\'umero decimal) (type {\tt
float}), y cadena o ``strings'' (type {\tt str}).
\index{type}

\item[valor:]  Uno de las unidades b\'asicas de datos, como un n\'umero o una cadena de palabras que un programa manipula.
\index{value}

\item[variable:]  Un nombre que se refiere a un valor.
=======
\item[comment:]  Information in a program that is meant for other
programmers (or anyone reading the source code) and has no effect on the
execution of the program.
\index{comment}

\item[evaluate:]  To simplify an expression by performing the operations
in order to yield a single value.

\item[expression:]  A combination of variables, operators, and values that
represents a single result value.
\index{expression}

\item[floating-point:] A type that represents numbers with fractional
parts.
\index{floating-point}

\item[floor division:] The operation that divides two numbers and chops off
the fraction part.
\index{floor division}

\item[integer:] A type that represents whole numbers.
\index{integer}

\item[keyword:]  A reserved word that is used by the compiler to parse a
program; you cannot use keywords like {\tt if}, {\tt  def}, and {\tt while} as
variable names.
\index{keyword}

\item[mnemonic:] A memory aid. We often give variables mnemonic names
to help us remember what is stored in the variable.
\index{mnemonic}

\item[modulus operator:]  An operator, denoted with a percent sign
({\tt \%}), that works on integers and yields the remainder when one
number is divided by another.
\index{modulus operator}
\index{operator!modulus}

\item[operand:]  One of the values on which an operator operates.
\index{operand}

\item[operator:]  A special symbol that represents a simple computation like
addition, multiplication, or string concatenation.
\index{operator}

\item[rules of precedence:]  The set of rules governing the order in which
expressions involving multiple operators and operands are evaluated.
\index{rules of precedence}
\index{precedence}

\item[statement:]  A section of code that represents a command or action.  So
far, the statements we have seen are assignments and print statements.
\index{statement}

\item[string:] A type that represents sequences of characters.
\index{string}

\item[type:] A category of values.  The types we have seen so far
are integers (type {\tt int}), floating-point numbers (type {\tt
float}), and strings (type {\tt str}).
\index{type}

\item[value:]  One of the basic units of data, like a number or string, 
that a program manipulates.
\index{value}

\item[variable:]  A name that refers to a value.
>>>>>>> origin/master
\index{variable}

\end{description}

\section{Exercises}

\begin{ex}
<<<<<<< HEAD
Escriba un programa que use \verb"raw_input" que requiera que el usuario entre su nombre y luego le de la bienvenida.
=======
Write a program that uses  \verb"raw_input" to prompt a user for their name 
and then welcomes them.
>>>>>>> origin/master

\begin{verbatim}
Enter your name: Chuck
Hello Chuck
\end{verbatim}

\end{ex}

\begin{ex}
<<<<<<< HEAD
Escriba un programa que requiera del usuario entrar las horas y el valor por hora para calcular el pago total.
=======
Write a program to prompt the user for hours and rate per hour to compute
gross pay.
>>>>>>> origin/master
\begin{verbatim}
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
\end{verbatim}
\end{ex}
%
<<<<<<< HEAD
No nos preocuparemos de que el salario tenga exactamente dos d\'igitos despu\'es del decimal, por ahora. Si usted quiere, puede ensayar con las functiones integradas de Python {\tt round} para redondear apropiadamente el resultado del pago en dos espacios decimales.

\begin{ex}
Asuma que ejecutamos la siguiente asignaci\'on de las afirmaciones:
=======
We won't worry about making sure our pay has exactly two digits after
the decimal place for now.  If you want, you can play with the 
built-in Python {\tt round} function to properly round the resulting pay
to two decimal places.

\begin{ex}
Assume that we execute the following assignment statements:
>>>>>>> origin/master

\begin{verbatim}
width = 17
height = 12.0
\end{verbatim}

<<<<<<< HEAD
Para cada una de las siguientes expresiones, escriba el valor de la expresi\'on y el tipo del valor de la expresi\'on.
=======
For each of the following expressions, write the value of the
expression and the type (of the value of the expression).
>>>>>>> origin/master

\begin{enumerate}

\item {\tt width/2}

\item {\tt width/2.0}

\item {\tt height/3}

\item {\tt 1 + 2 * 5}

\end{enumerate}

<<<<<<< HEAD
Use el int\'erprete de Python para verificar sus respuestas.
\end{ex}

\begin{ex}
Escriba un programa que requiera que el usuario entre la temperatura en celsius,
convierta la medida a Fahrenheit e imprima el resultado de la temperatura que ha sido convertida.
=======
Use the Python interpreter to check your answers.
\end{ex}

\begin{ex}
Write a program which prompts the user for a Celsius temperature,
convert the temperature to Fahrenheit and print out the converted
temperature.
>>>>>>> origin/master
\end{ex}


